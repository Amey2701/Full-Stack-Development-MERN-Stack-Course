ðŸ“˜ JavaScript Functions & Asynchronous Programming (Lecture Notes)
ðŸ”¹ 1. Functions in JavaScript
ðŸ“– Definition

A function is a block of reusable code designed to perform a specific task.

You write the logic once.

You can execute it many times.

Functions help keep code modular, reusable, and readable.

ðŸ“ Syntax:
function functionName(parameters) {
    // block of code
    return value;
}

ðŸ“Œ Types of Functions

Built-in Functions (provided by JS)
Examples: alert(), prompt(), parseInt(), setTimeout()

User-defined Functions (written by developers)

a) Named Function
function greet() {
    console.log("Hello!");
}
greet();


âœ… Reusable, readable.

b) Function Expression / Anonymous Function
const add = function(a, b) {
    return a + b;
}
console.log(add(2, 3)); // 5


âœ… Function without a name, stored in a variable.

c) Arrow Function (ES6+)
const square = (n) => n * n;
console.log(square(5)); // 25


âœ… Shorter syntax, useful in callbacks.

d) IIFE (Immediately Invoked Function Expression)
(function() {
    console.log("IIFE executed immediately!");
})();


âœ… Runs as soon as itâ€™s defined, avoids polluting global scope.

ðŸ”¹ 2. Synchronous vs Asynchronous Programming
ðŸ“– Synchronous

Code runs line by line.

Each task waits for the previous one to finish.

âŒ Problem: If one task takes time â†’ blocks the whole program.

console.log("Step 1");
console.log("Step 2");
console.log("Step 3");

// Output: Step 1 -> Step 2 -> Step 3

ðŸ“– Asynchronous

Tasks donâ€™t block each other.

Some tasks run in the background.

Browser helps handle async operations (like timers, fetch, events).

console.log("Start");

setTimeout(() => console.log("Async Task done"), 2000);

console.log("End");

// Output:
// Start
// End
// Async Task done (after 2s)


âœ… Notice: "End" printed before async task completes.

ðŸ”¹ 3. How Asynchronous JS Works Internally

JavaScript is single-threaded â†’ only one call stack.
But event loop + callback queue + Web APIs make async possible.

1ï¸âƒ£ Call Stack (LIFO)

Where JS executes functions.

Last In, First Out.

function a(){ console.log("A"); }
function b(){ a(); console.log("B"); }
b();
// Call Stack flow: push b() â†’ push a() â†’ log A â†’ pop a() â†’ log B â†’ pop b()

2ï¸âƒ£ Web APIs (Browser APIs)

Provided by browser (not core JS).

Examples: setTimeout, setInterval, fetch, DOM events.

These APIs run tasks in the background.

Example: setTimeout

setTimeout(() => console.log("Executed after 1s"), 1000);


âœ… Runs after 1 second without blocking main thread.

Example: setInterval

let id = setInterval(() => console.log("Repeats every 2s"), 2000);
clearInterval(id); // stops interval

3ï¸âƒ£ Callback Queue (FIFO)

Stores callbacks waiting to run.

Waits for call stack to be empty.

Types:

Macrotask Queue â†’ setTimeout, setInterval, events

Microtask Queue â†’ Promises, async/await

âš¡ Microtasks have higher priority than Macrotasks.

Example:

console.log("Start");

setTimeout(() => console.log("Macrotask (setTimeout)"), 0);

Promise.resolve().then(() => console.log("Microtask (Promise)"));

console.log("End");

// Output:
// Start
// End
// Microtask (Promise)
// Macrotask (setTimeout)

4ï¸âƒ£ Event Loop

Like a traffic controller.

Keeps checking:

Is the call stack empty?

If yes â†’ take first task from queue â†’ push into stack.

Example (macrotask.js explained):

console.log('start');

setTimeout(()=> console.log('Timeout executed!'), 500);
setTimeout(()=> console.log('Timeout with ZERO delay!'), 0);

console.log('end');


Step-by-step working:

Call stack â†’ executes "start".

Encounters setTimeout â†’ browser handles it (Web API).

Logs "end".

Event loop checks â†’ stack empty? Yes â†’ push setTimeout callback from queue.

Executes â†’ "Timeout executed!" and "Timeout with ZERO delay!".

âœ… Final Output:

start
end
Timeout with ZERO delay!
Timeout executed!

ðŸ”¹ 4. Practical Uses of Asynchronous JS

Making API calls (fetch) without blocking UI.

Handling user events (click, scroll).

Running background tasks (timers, animations).

Processing files/data without freezing page.

2. Macrotasks (setTimeout)
ðŸ“– Definition
A Macrotask is a piece of code scheduled to run later, after the current call stack is empty.

setTimeout and setInterval use the Macrotask Queue.

Even if delay = 0 ms, the callback doesnâ€™t run immediately; it waits until the call stack is free.

ðŸ“Œ Flow with setTimeout
setTimeout is encountered in code.

Timer is handled by Web API (provided by browser).

After delay, callback is moved to the Macrotask Queue.

Event Loop checks: Is Call Stack empty?

If yes â†’ callback moved to stack â†’ executes.

If no â†’ waits until stack clears.

ðŸ“„ Example Code
// ==========================
// MACROTASK with setTimeout
// ==========================

console.log("Start");

// Schedule 2 tasks using setTimeout
setTimeout(() => console.log("Timeout callback executed after 500ms!"), 500);
setTimeout(() => console.log("Timeout callback executed with ZERO delay!"), 0);

console.log("End");

/*
Step-by-step execution:
1. Call Stack executes console.log("Start") â†’ output: Start
2. setTimeout(500) â†’ handled by Web API, callback goes to Macrotask Queue after 500ms
3. setTimeout(0) â†’ handled by Web API, callback goes to Macrotask Queue after ~0ms
4. Call Stack executes console.log("End") â†’ output: End
5. Event Loop checks â†’ stack empty?
   - YES â†’ executes 0ms setTimeout callback
   - Then executes 500ms setTimeout callback

Output:
Start
End
Timeout callback executed with ZERO delay!
Timeout callback executed after 500ms!
*/
âœ… Key Point: Even with 0ms, callback runs after synchronous code completes.